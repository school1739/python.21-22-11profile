# Определяет, можно ли выиграть из этой позиции одним ходом
def win1(n):
    if n + 5 >= 78 or n * 4 - 3 >= 78:
        return True
    return False


# Определяет, является ли позиция проигрышной одним ходом
def loss1(n):
    # Проигрышная позиция - такая позиция, из которой можно выиграть только сдедующим ходом
    if not win1(n) and win1(n+5) and win1(n*4-3):
        return True
    return False


# Проверяем, является ли позиция выигрышной за 2 хода
# Она будет таковой, если при любом раскладе следующий ход гарантированно проигрышный
def win2(n):
    if loss1(n + 5) or loss1(n * 4 - 3):
        return True
    return False


# Проверяем, является ли позиция проигрышной за 1 или 2 хода
# Она будет таковой, если при в одном случае одна из следующих позиций выигрышная за 1 ход, другая за 2
# и наоборот
def loss12(n):
    if (win1(n + 5) and win2(n * 4 - 3)) or (win1(n * 4 - 3) and win2(n + 5)):
        return True
    return False


# Перебор всех вариантов для №19
for i in range(1, 78):
    # Если следующая позиция выигрышная, то выводим эту позицию
    if win1(i + 5) or win1(i * 4 - 3):
        print('19:', i)
        break

# Кортеж всех ответов на №20 (можно просто список)
answ = set()
# Перебор всех вариантов для №20
for i in range(1, 78):
    # Если эта позиция выигрышная за 2 хода, то добавляем эту позицию
    if win2(i):
        answ.add(i)

print('20:', min(answ), max(answ))

# Кортеж всех ответов на №21 (можно просто список)
answ = set()
# Перебор всех вариантов для №21
for i in range(1, 78):
    # Если эта позиция выигрышная за 2 хода, то добавляем эту позицию
    if win2(i):
        answ.add(i)

print('21:', min(answ))
